<html>
  <head>
    <link rel="stylesheet"
      href="vendor/default.min.css">
    <script src="vendor/highlight.min.js"></script>

    <script src="vendor/diff_match_patch.js"></script>

    <style>
     code { font-family: Operator Mono SSm, monospace; position: relative; }
     #shadow { position: absolute; right: 0; top: 0; }

     .character { display: inline-block; transition: transform 1s ease-in-out; }
     .macro .character { background-color: pink; outline: 1px solid pink; }
     .macro:hover .character { background-color: orange; outline: 1px solid orange; }
     
     .highlighted-shadow-char { outline: 1px solid orange; }

     #canv { position: absolute; left: 0; top: 0; outline: 1px solid red; }

     body { margin: 0; }
    </style>
  </head>

  <body>
    <canvas width="800" height="1000" id="canv"></canvas>

    <script>
     const mainText = `
#define exchange_json(datap, sizep, keys_fmt, ...) \\
    do { \\
        unsigned int id = (uintptr_t)pthread_self(); \\
        int req_rv = do_exchange(id, datap, sizep, \\
            "{id: %u, " keys_fmt "}", \\
            id, ##__VA_ARGS__); \\
        if (req_rv != 0) return req_rv; \\
    } while (0)

#define parse_and_free_response(data, size, keys_fmt, ...) \\
    do { \\
        if (*keys_fmt == '\\0') { \\
            /* empty format string, skip the work */ \\
            free(data); data = NULL; \\
        } else { \\
            int num_expected = count_fmt_args(keys_fmt); \\
            int num_scanned = json_scanf(data, size, \\
                "{" keys_fmt "}", \\
                ##__VA_ARGS__); \\
            if (num_scanned == num_expected) { \\
                free(data); data = NULL; \\
            } else { \\
                eprintln("%s: could only parse %d of %d keys!", \\
                    __func__, num_expected, num_scanned); \\
                free(data); data = NULL; \\
                return -EIO; \\
            } \\
        } \\
    } while (0)

static int tabfs_getattr(const char *path, struct stat *stbuf) {
    char *rdata;
    size_t rsize;
    exchange_json(&rdata, &rsize,
        "op: %Q, path: %Q",
        "getattr", path);

    memset(stbuf, 0, sizeof(struct stat));
    parse_and_free_response(rdata, rsize,
        "st_mode: %d, st_nlink: %d, st_size: %d",
        &stbuf->st_mode, &stbuf->st_nlink, &stbuf->st_size);

    return 0;
}
     `.trim();

     const shadowText = `
#define exchange_json(datap, sizep, keys_fmt, ...) \\
    do { \\
        unsigned int id = (uintptr_t)pthread_self(); \\
        int req_rv = do_exchange(id, datap, sizep, \\
            "{id: %u, " keys_fmt "}", \\
            id, ##__VA_ARGS__); \\
        if (req_rv != 0) return req_rv; \\
    } while (0)

#define parse_and_free_response(data, size, keys_fmt, ...) \\
    do { \\
        if (*keys_fmt == '\\0') { \\
            /* empty format string, skip the work */ \\
            free(data); data = NULL; \\
        } else { \\
            int num_expected = count_fmt_args(keys_fmt); \\
            int num_scanned = json_scanf(data, size, \\
                "{" keys_fmt "}", \\
                ##__VA_ARGS__); \\
            if (num_scanned == num_expected) { \\
                free(data); data = NULL; \\
            } else { \\
                eprintln("%s: could only parse %d of %d keys!", \\
                    __func__, num_expected, num_scanned); \\
                free(data); data = NULL; \\
                return -EIO; \\
            } \\
        } \\
    } while (0)

static int tabfs_getattr(const char *path, struct stat *stbuf) {
    char *rdata;
    size_t rsize;
    do { \\
        unsigned int id = (uintptr_t)pthread_self(); \\
        int req_rv = do_exchange(id, &rdata, &rsize, \\
            "{id: %u, " "op: %Q, path: %Q" "}", \\
            id, "getattr", path); \\
        if (req_rv != 0) return req_rv; \\
    } while (0);

    memset(stbuf, 0, sizeof(struct stat));
    parse_and_free_response(rdata, rsize,
        "st_mode: %d, st_nlink: %d, st_size: %d",
        &stbuf->st_mode, &stbuf->st_nlink, &stbuf->st_size);

    return 0;
}`.trim();

     const renderer = (function() {
       function setDPI(canvas, dpi) {
         // Set up CSS size.
         canvas.style.width = canvas.style.width || canvas.width + 'px';
         canvas.style.height = canvas.style.height || canvas.height + 'px';

         // Resize canvas and scale future draws.
         var scaleFactor = dpi / 96;
         canvas.width = Math.ceil(canvas.width * scaleFactor);
         canvas.height = Math.ceil(canvas.height * scaleFactor);
         var ctx = canvas.getContext('2d');
         ctx.scale(scaleFactor, scaleFactor);
       }
       
       const canvas = document.querySelector('canvas');
       setDPI(canvas, 192);

       const ctx = canvas.getContext('2d');
       ctx.textBaseline = 'top';
       ctx.font = '1em Operator Mono SSm, monospace';
       const metrics = ctx.measureText('m');

       function charIndexUnder(x, y) {
         for (let [i, char] of mainChars.entries()) {
           if (char.x < x && char.y < y &&
               x < char.x + metrics.width && y < char.y + 18) {
             return i;
           }
         }
       }

       canvas.onmousemove = function(e) {
         const charIdx = charIndexUnder(e.offsetX, e.offsetY);
         const char = mainChars[charIdx];
         if (!char) return;

         ctx.save();
         ctx.fillStyle = 'green';
         ctx.fillRect(char.x, char.y, metrics.width, 18);
         ctx.restore();
         renderer.render(mainChars, charIdx, charIdx + 1);

         const shadowIdx = char.shadowIndex;
         const shadowChar = shadowChars[shadowIdx];
         ctx.save();
         ctx.translate(600, 0);
         ctx.save();
         ctx.fillStyle = 'orange';
         ctx.fillRect(shadowChar.x, shadowChar.y, metrics.width, 18);
         ctx.restore();
         renderer.render(shadowChars, shadowIdx, shadowIdx + 1);
         ctx.restore();
       };

       canvas.onmousedown = function(e) {
         // FIXME: animate to shadow positions
         function easeInOutCubic(x) {
           return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
         }

         let duration = 1; // in seconds
         let t = 0;
         const interval = setInterval(function() {
           for (let char of mainChars) {
             char.ox = char.x; char.oy = char.y
             char.x = char.ox* (1-easeInOutCubic(t/duration)) + shadowChars[char.shadowIndex].x * easeInOutCubic(t/duration);
             char.y = char.oy* (1-easeInOutCubic(t/duration)) + shadowChars[char.shadowIndex].y * easeInOutCubic(t/duration);
           }
           ctx.clearRect(0, 0, 1000, 1000);
           renderer.render(mainChars, 0, mainChars.length - 1, false);
           renderer.render(createChars, 0, createChars.length - 1, false);

           t += 10 * 0.001;
           if (t >= duration) {
             clearInterval(interval);
           }
         }, 10);
       };

       return {
         render(chars, startIdx = 0, endIdx = chars.length - 1, computePositions = true) {
           let {x, y} = chars[startIdx];
           for (let i = startIdx; i <= endIdx; i++) {
             const char = chars[i];

             if (computePositions) { char.x = x; char.y = y; }
             ctx.fillText(char.c, char.x, char.y);

             if (char.c === '\n') {
               x = 0;
               y += 18;
             } else {
               x += metrics.width;
             }
           }
         },
         ctx
       };
     })();

     const mainChars = mainText.split('').map(c => ({c, x: 0, y: 0}));
     renderer.render(mainChars);

     const shadowChars = shadowText.split('').map(c => ({c, x: 0, y: 0}));
     renderer.ctx.save();
     renderer.ctx.translate(600, 0);
     renderer.render(shadowChars);
     renderer.ctx.restore();
     
     // function spanify(s) {
     //   return s.replace(/(.)/g, '<span class="character">$1</span>')
     //           .replace(/\n/g, '<span class="character">\n</span>\n');
     // }
     // 
     //      const [main, shadow] = [document.getElementById('main'), document.getElementById('shadow')];
     // 
     //      main.innerHTML = spanify(mainText)
     //        .replace(new RegExp(spanify('exchange_json'), 'g'),
     //                 `<span class="macro exchange_json">${spanify('exchange_json')}</span>`)
     //        .replace(new RegExp(spanify('parse_and_free_response'), 'g'),
     //                 `<span class="macro">${spanify('parse_and_free_response')}</span>`);
     // 
     //      shadow.innerHTML = spanify(shadowText);

     // get pos of each char

     const differ = new diff_match_patch();
     const diffs = differ.diff_main(mainText, shadowText);
     differ.diff_cleanupSemantic(diffs);
     console.log(diffs);

     // document.body.innerHTML = '<pre>' + differ.diff_prettyHtml(diffs) + '</pre>';

     // document.querySelectorAll('pre code').forEach((block) => {
     //   hljs.highlightBlock(block);
     // });

     // const targetMap = new Map();
     // 

     let i = 0, shadowI = 0;
     const createChars = [];
     for (let {0: kind, 1: text} of diffs) {
       if (kind === 0) {
         let textEnd = i + text.length;
         while (i < textEnd) {
           mainChars[i].shadowIndex = shadowI;
           i++; shadowI++;
         }
       } else if (kind === -1) {
         let textEnd = i + text.length;
         while (i < textEnd) {
           // mainChars[i].style.backgroundColor = 'red';
           mainChars[i].shadowIndex = 0;
           i++;
         }
         
       } else if (kind === 1) {
         let textEnd = shadowI + text.length;
         while (shadowI < textEnd) {
           // const span = shadowChars[shadowI].cloneNode(true);
           // span.style.position = 'absolute';
           // span.style.top = shadowChars[shadowI].offsetTop;
           // span.style.left = shadowChars[shadowI].offsetLeft;
           // creation.appendChild(span);
           createChars.push({...shadowChars[shadowI]})
           shadowI++;
         }
       }
     }
     // 
     // for (let [i, char] of mainChars.entries()) {
     //   const shadowChar = shadowChars[char.shadowIndex];
     //   const [top, left] = [char.offsetTop, char.offsetLeft];
     //   const [shadowTop, shadowLeft] = [shadowChar.offsetTop, shadowChar.offsetLeft];
     //   targetMap.set(char, {dx: shadowLeft - left, dy: shadowTop - top});
     // }
     // 
     // document.onmousemove = function(e) {
     //   const char = e.target.closest('#main .character');
     //   if (!char) return;
     //   
     //   // console.log(char.shadowIndex);
     //   const shadowChar = shadowChars[char.shadowIndex];
     //   [...document.getElementsByClassName('highlighted-shadow-char')]
     //     .forEach(sc => sc.classList.remove('highlighted-shadow-char'));
     //   shadowChar.classList.add('highlighted-shadow-char');
     // }
     // 
     // document.querySelectorAll('.exchange_json')[1].onmousedown = function(e) {
     //   for (let char of mainChars) {
     //     const {dx, dy} = targetMap.get(char);
     //     char.style.transform = `translate(${dx}px, ${dy}px)`;
     //   }
     //   
     //   creations.forEach(c => { main.appendChild(c); });
     // }
    </script>
  </body>
</html>
