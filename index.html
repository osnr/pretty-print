<html>
  <head>
    <script src="vendor/diff_match_patch.js"></script>

    <style>
     #canv { position: absolute; left: 0; top: 0; }
 
     body { margin: 0; overflow: hidden; }
    </style>
  </head>

  <body>
    <canvas width="2000" height="2000" id="canv"></canvas>

    <script>
     let obj = {
       "manifest_version": 2,

       "name": "TabFS",
       "description": "Mount your browser tabs as a filesystem",
       "version": "1.0",

       "permissions": [
         "tabs", "tabCapture", "debugger", "nativeMessaging", "management",
         "unlimitedStorage",
         "<all_urls>"
       ],

       "background": {
         "scripts": ["vendor/browser-polyfill.js", "background.js"],
         "persistent": true
       },

       "browser_specific_settings": {
         "gecko": {
           "id": "tabfs@rsnous.com"
         }
       }
     };
     // source text (what shows up on the screen initially)
     let mainText = JSON.stringify(obj);
     // target text (what the source text animates into when you mousedown)
     let shadowText = JSON.stringify(obj, null, 2);

     const canvas = document.querySelector('canvas');

     const Renderer = (function() {
       function setDPI(canvas, dpi) {
         // Set up CSS size.
         canvas.style.width = canvas.style.width || canvas.width + 'px';
         canvas.style.height = canvas.style.height || canvas.height + 'px';

         // Resize canvas and scale future draws.
         var scaleFactor = dpi / 96;
         canvas.width = Math.ceil(canvas.width * scaleFactor);
         canvas.height = Math.ceil(canvas.height * scaleFactor);
         var ctx = canvas.getContext('2d');
         ctx.scale(scaleFactor, scaleFactor);
       }
       setDPI(canvas, 192);

       const ctx = canvas.getContext('2d');
       ctx.textBaseline = 'top';
       ctx.font = '1em Operator Mono SSm, monospace';
       const metrics = ctx.measureText('m');
       console.log(metrics);

       function computePositions(chars) {
         let {x, y} = chars[0];
         for (let char of chars) {
           char.x = x; char.y = y;
           if (char.c === '\n' || char.x > 700) {
             x = 0;
             y += metrics.fontBoundingBoxDescent + 1;
           } else {
             x += metrics.width;
           }
         }
       }

       return {
         computePositions,
         charIndexUnder(x, y) {
           for (let [i, char] of mainChars.entries()) {
             if (char.x < x && char.y < y &&
                 x < char.x + metrics.width &&
                 y < char.y + metrics.fontBoundingBoxDescent + 1) {
               return i;
             }
           }
         },
         clear() { ctx.clearRect(0, 0, 1000, 500); },
         render(chars, startIdx = 0, endIdx = chars.length - 1) {
           for (let i = startIdx; i <= endIdx; i++) {
             const char = chars[i];
             ctx.fillText(char.c,
                          'animX' in char ? char.animX : char.x,
                          'animY' in char ? char.animY : char.y);
           }
         },
         ctx
       };
     })();

     const Animator = (function() {
       const renderFrame = (function() {
         function easeInOutCubic(x) {
           return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
         }

         function animate(x0, x1, t, ease = easeInOutCubic) {
           return x0 * (1 - ease(t)) + x1 * ease(t);
         }

         return function frame(t) {
           for (let char of mainChars) {
             if ('shadowIndex' in char) {
               const shadowChar = shadowChars[char.shadowIndex];
               char.animX = animate(char.x, shadowChar.x, t);
               char.animY = animate(char.y, shadowChar.y, t);
             } else {
               char.fillStyle = `rgba(0, 0, 0, ${animate(1, 0, t)})`;
             }
           }

           Renderer.clear();
           Renderer.render(mainChars);

           for (let createChars of createCharRuns) {
             createChars.forEach(char => {
               char.fillStyle = `rgba(0, 0, 0, ${animate(0, 1, t)})`;
             });
             Renderer.render(createChars);
           }
         };
       })();
       
       let target = 0, rate, slowMode;

       let t = 0;
       requestAnimationFrame(timestamp => {
         (function frame(prevTimestamp, timestamp) {
           if (Math.abs(target - t) > 0.1) {
             t += (target - t) / (timestamp - prevTimestamp) * rate;
             renderFrame(t);
           } else {
             // FIXME: stop animation
           }

           requestAnimationFrame(newTimestamp => frame(timestamp, newTimestamp));
         })(timestamp - 20, timestamp)
       });

       return {
         get target() { return target; },
         set target(t) {
           target = t;
           // FIXME: dynamically stop/start animation
         },
         get rate() { return rate; },
         set rate(s) { rate = s; },
         get slowMode() { return slowMode; },
         set slowMode(sm) { slowMode = sm; }
       };
     })();

     const mainChars = mainText.split('').map(c => ({c, x: 0, y: 0}));
     Renderer.computePositions(mainChars);
     Renderer.render(mainChars);

     const shadowChars = shadowText.split('').map(c => ({c, x: 0, y: 0}));
     Renderer.computePositions(shadowChars);

     const diffs = (function() {
       const differ = new diff_match_patch();
       const diffs = differ.diff_main(mainText, shadowText);
       // differ.diff_cleanupSemantic(diffs);
       return diffs;
     })();

     const createCharRuns = (function() {
       const createCharRuns = [];
       let i = 0, shadowI = 0;
       for (let {0: kind, 1: text} of diffs) {
         if (kind === 0) {
           let textEnd = i + text.length;
           while (i < textEnd) {
             mainChars[i].shadowIndex = shadowI;
             i++; shadowI++;
           }
         } else if (kind === -1) {
           let textEnd = i + text.length;
           while (i < textEnd) {
             i++;
           }
           
         } else if (kind === 1) {
           const createChars = [];
           let textEnd = shadowI + text.length;
           while (shadowI < textEnd) {
             createChars.push({...shadowChars[shadowI]})
             shadowI++;
           }
           createCharRuns.push(createChars);
         }
       }
       return createCharRuns;
     })();

     canvas.onmousemove = function(e) {
       const charIdx = Renderer.charIndexUnder(e.offsetX, e.offsetY);
       const char = mainChars[charIdx];
       if (!char) { document.body.style.cursor = 'auto'; return; }

       document.body.style.cursor = 'pointer';
     };
     canvas.onmousedown = canvas.ontouchstart = function(e) { Animator.target = 1; Animator.rate = 1; };
     canvas.onmouseup = canvas.ontouchend = function(e) { Animator.target = 0; Animator.rate = 2; };
     document.onkeydown = document.onkeyup = function(e) { Animator.slowMode = e.shiftKey; }
    </script>
  </body>
</html>
