<html>
  <head>
    <script src="vendor/diff_match_patch.js"></script>

    <style>
     #canv { position: absolute; left: 0; top: 0; outline: 1px solid red; }

     body { margin: 0; }
    </style>
  </head>

  <body>
    <canvas width="800" height="1000" id="canv"></canvas>

    <script>
     let obj = {
  "manifest_version": 2,

  "name": "TabFS",
  "description": "Mount your browser tabs as a filesystem",
  "version": "1.0",

  "permissions": [
    "tabs", "tabCapture", "debugger", "nativeMessaging", "management",
    "unlimitedStorage",
    "<all_urls>"
  ],

  "background": {
    "scripts": ["vendor/browser-polyfill.js", "background.js"],
    "persistent": true
  },

  "browser_specific_settings": {
    "gecko": {
      "id": "tabfs@rsnous.com"
    }
  }
};
     let mainText = JSON.stringify(obj);
     let shadowText = JSON.stringify(obj, null, 2);

     const renderer = (function() {
       function setDPI(canvas, dpi) {
         // Set up CSS size.
         canvas.style.width = canvas.style.width || canvas.width + 'px';
         canvas.style.height = canvas.style.height || canvas.height + 'px';

         // Resize canvas and scale future draws.
         var scaleFactor = dpi / 96;
         canvas.width = Math.ceil(canvas.width * scaleFactor);
         canvas.height = Math.ceil(canvas.height * scaleFactor);
         var ctx = canvas.getContext('2d');
         ctx.scale(scaleFactor, scaleFactor);
       }
       
       const canvas = document.querySelector('canvas');
       setDPI(canvas, 192);

       const ctx = canvas.getContext('2d');
       ctx.textBaseline = 'top';
       ctx.font = '1em Operator Mono SSm, monospace';
       const metrics = ctx.measureText('m');
       console.log(metrics);

       function charIndexUnder(x, y) {
         for (let [i, char] of mainChars.entries()) {
           if (char.x < x && char.y < y &&
               x < char.x + metrics.width && y < char.y + metrics.emHeightDescent) {
             return i;
           }
         }
       }

       canvas.onmousemove = function(e) {
         const charIdx = charIndexUnder(e.offsetX, e.offsetY);
         const char = mainChars[charIdx];
         if (!char) { document.body.style.cursor = 'auto'; return; }

         ctx.clearRect(0, 0, 1000, 1000);
         
         document.body.style.cursor = 'pointer';
         
         renderer.render(mainChars);
       };

       function easeInOutCubic(x) {
         return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
       }
       function runAnimation(fn, duration) {
         let t0 = performance.now();
         let fixed = {};
         requestAnimationFrame(function frame(t) {
           let key = 0;
           fn(function fix(x) {
             if (key in fixed) { x = fixed[key]; }
             else { fixed[key] = x; }
             key++; return x;
           }, function animate(x0, x1, ease = easeInOutCubic) {
             return x0 * (1 - ease((t - t0) / duration)) + x1 * ease((t - t0) / duration);
           });

           if (t < t0 + duration) {
             requestAnimationFrame(frame);
           }
         });
       }

       canvas.onmousedown = function(e) {
         canvas.oldonmousemove = canvas.onmousemove;
         canvas.onmousemove = null;

         runAnimation((fix, animate) => {
           for (let char of mainChars) {
             if ('shadowIndex' in char) {
               const shadowChar = shadowChars[char.shadowIndex];
               char.x = animate(fix(char.x), shadowChar.x);
               char.y = animate(fix(char.y), shadowChar.y);
             } else {
               char.fillStyle = `rgba(0, 0, 0, ${animate(1, 0)})`;
             }
           }

           ctx.clearRect(0, 0, 1000, 1000);

           renderer.render(mainChars);

           for (let createChars of createCharRuns) {
             createChars.forEach(char => {
               char.fillStyle = `rgba(0, 0, 0, ${animate(0, 1)})`;
             });
             renderer.render(createChars);
           }
         }, e.shiftKey ? 2000 : 500);
       };
       document.onmouseup = function(e) {         
         runAnimation((fix, animate) => {
           computePositions(mainChars);
           
           for (let char of mainChars) {
             if ('shadowIndex' in char) {
               const shadowChar = shadowChars[char.shadowIndex];
               char.x = animate(shadowChar.x, fix(char.x));
               char.y = animate(shadowChar.y, fix(char.y));
             } else {
               char.fillStyle = `rgba(0, 0, 0, ${animate(0, 1)})`;
             }
           }
           ctx.clearRect(0, 0, 1000, 1000);
           renderer.render(mainChars);

           for (let createChars of createCharRuns) {
             createChars.forEach(char => {
               char.fillStyle = `rgba(0, 0, 0, ${animate(1, 0)})`;
             });
             renderer.render(createChars);
           }
         }, 1000);
         setTimeout(() => {
           canvas.onmousemove = canvas.oldonmousemove;
         }, 1000);
       };

       function computePositions(chars) {
         let {x, y} = chars[0];
         for (let char of chars) {
           char.x = x; char.y = y;
           if (char.c === '\n' || char.x > 700) {
             x = 0;
             y += metrics.emHeightDescent;
           } else {
             x += metrics.width;
           }
         }
       }

       return {
         computePositions,
         render(chars, startIdx = 0, endIdx = chars.length - 1) {
           for (let i = startIdx; i <= endIdx; i++) {
             const char = chars[i];
             ctx.fillText(char.c, char.x, char.y);
           }
         },
         ctx
       };
     })();

     const mainChars = mainText.split('').map(c => ({c, x: 0, y: 0}));
     renderer.computePositions(mainChars);
     renderer.render(mainChars);

     const shadowChars = shadowText.split('').map(c => ({c, x: 0, y: 0}));
     renderer.computePositions(shadowChars);

     const differ = new diff_match_patch();
     const diffs = differ.diff_main(mainText, shadowText);
     // differ.diff_cleanupSemantic(diffs);
     console.log(diffs);

     let i = 0, shadowI = 0;
     const createCharRuns = [];
     for (let {0: kind, 1: text} of diffs) {
       if (kind === 0) {
         let textEnd = i + text.length;
         while (i < textEnd) {
           mainChars[i].shadowIndex = shadowI;
           i++; shadowI++;
         }
       } else if (kind === -1) {
         let textEnd = i + text.length;
         while (i < textEnd) {
           i++;
         }
         
       } else if (kind === 1) {
         const createChars = [];
         let textEnd = shadowI + text.length;
         while (shadowI < textEnd) {
           createChars.push({...shadowChars[shadowI]})
           shadowI++;
         }
         createCharRuns.push(createChars);
       }
     }
    </script>
  </body>
</html>
